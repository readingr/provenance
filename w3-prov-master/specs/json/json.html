<!DOCTYPE html>

<html><head> 
    <title>The PROV-JSON Serialization</title> 
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
    <!-- 
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
<!-- PM -->
    <style type="text/css">
    @import url("extra.css");

      .note { font-size:small; margin-left:50px }
     .code-comment {
	color: #808080;
}
    .code-new {
	color: #000080;
}
    </style>

<script src="http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js" class="remove"></script> 
    <script class="remove"> 
      var addExtraReferences = function() {
          for (var k in extraReferences)
              berjon.biblio[k] = extraReferences[k];
      };
      var extraReferences = {
		  "PROV-DM":
          "Luc Moreau, Paolo Missier"+
          "<a href=\"http://www.w3.org/TR/prov-dm/\"><cite>PROV-DM: The PROV Data Model</cite></a>. "+
          "2012, Work in progress. "+
          "URL: <a href=\"http://www.w3.org/TR/prov-dm/\">http://www.w3.org/TR/prov-dm/</a>",
          "JSON-SCHEMA":
          "Kris Zyp and Gary Court "+
          "<a href=\"http://tools.ietf.org/html/draft-zyp-json-schema-03\"><cite>A JSON Media Type for Describing the Structure and Meaning of JSON Documents</cite></a>. "+
          "2011, Draft 3. "+
          "URL: <a href=\"http://tools.ietf.org/html/draft-zyp-json-schema-03\">http://tools.ietf.org/html/draft-zyp-json-schema-03</a>",
/*
        "PROV-PRIMER":
          "Yolanda Gil and Simon Miles "+
          "<a href=\"http://www.w3.org/TR/prov-primer/\"><cite>PROV Model Primer</cite></a>. "+
          "2012, Work in progress. "+
          "URL: <a href=\"http://www.w3.org/TR/prov-primer/\">http://www.w3.org/TR/prov-primer/</a>",

        "PROV-O":
          "Timothy Lebo, Satya Sahoo and Deborah McGuinness "+
          "<a href=\"http://www.w3.org/TR/prov-o/\"><cite>PROV-O: The PROV Ontology</cite></a>. "+
          "2012, Work in progress. "+
          "URL: <a href=\"http://www.w3.org/TR/prov-o/\">http://www.w3.org/TR/prov-o/</a>",

        "PROV-PAQ":
          "Graham Klyne and Paul Groth "+
          "<a href=\"http://www.w3.org/TR/prov-aq/\"><cite>PROV-AQ: Provenance Access and Query</cite></a>. "+
          "2011, Work in progress. "+
          "URL: <a href=\"http://www.w3.org/TR/prov-aq/\">http://www.w3.org/TR/prov-aq/</a>",
*/      };
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "prov-json",
 
          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          subtitle   :  "Working draft for internal discussion",
 
          // if you wish the publication date to be other than today, set this
          // publishDate:  "2011-10-18",
 
          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"
 
          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "2011-10-18",
          // previousMaturity:  "FPWD",
 
          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://dvcs.w3.org/hg/prov/raw-file/default/model/JSON.html",
 
          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",
 
          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          extraCSS:             ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css", "./extra.css"],
 
          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Trung Dong Huynh", url: "http://users.ecs.soton.ac.uk/tdh/",
                company: "University of Southampton" },
          ],
 
          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.
 
          authors:  [
              { name: "Michael O. Jewell", url: "http://www.ecs.soton.ac.uk/people/moj",
			  	company: "University of Southampton" },
              { name: "Amir Sezavar Keshavarz", url: "http://www.ecs.soton.ac.uk/people/ask2g10",
			  	company: "University of Southampton" },
			  { name: "Danius T. Michaelides", url: "http://users.ecs.soton.ac.uk/dtm/",
			  	company: "University of Southampton" },
              { name: "Luc Moreau", url: "http://users.ecs.soton.ac.uk/lavm/",
			  	company: "University of Southampton" },
              { name: "Huanjia Yang", url: "http://www.ecs.soton.ac.uk/people/hy2",
			  	company: "University of Southampton" },
          ],
          
          // name of the WG
          wg:           "Provenance Working Group",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/2011/prov/",
          
          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-prov-wg",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/46974/status",

          // Add extraReferences to bibliography database
          preProcess: [addExtraReferences],
      };
    </script> 
  </head> 

<body> 

<section id="abstract">
<p>
This document specifies a provenance representation in JSON, called PROV-JSON, for the W3C's Provenance Data Model (PROV-DM).</p>
</section> 
   
<section> 
<h2>Introduction</h2> 

<p> PROV-JSON is a JSON representation for the Provenance Data Model (PROV-DM). The representation was developed internally at the University of Southampton as a common format for exchanging provenance information in web applications between research projects. At the same time, the PROV-JSON representation aims at facilitating client-side manipulations of provenance information and allowing the use of a generic client-side API in various web applications. Since it is based on the Provenance Data Model [[PROV-DM]] being standardized at the <a href="http://www.w3.org/2011/prov/">W3C Provenance Working Group</a>, it is hoped that the PROV-JSON representation will also benefit, and find support from, a wider community.</p>

<p>Note: The PROV-JSON mappings introduced later in this document were defined based specifically on the <a href="http://www.w3.org/TR/2011/prov-dm/">second working draft of PROV-DM</a>. As the PROV-DM document evolves, changes there will be incorporated back into this document at a later version. However, in the meantime, the readers should be aware that there might be misalignments between this document and the latest version of PROV-DM.</p>

<h3>Design considerations</h3>
<p>The development of the PROV-JSON representation has the following goals:</p>
<ul>
  <li><strong>Interoperability</strong>: PROV-JSON aims to map closely the Provenance Data Model in order to ensure the interoperability between applications adopting the W3C's future recommendation. Therefore, provenance information represented in PROV-JSON can be converted from and to its counterpart in the Provenance Abstract Syntax Notation (PROV-ASN) of PROV-DM.</li>
  <li><strong>Lightweight</strong>: native JavaScript data types are used where possible.</li>
  <li><strong>Extensibility</strong>: application-specific terms and data can be introduced via the use of namespaces and custom data types.</li>
  <li><strong>Ease of use</strong>: The design of PROV-JSON aims to follow the <a href="http://en.wikipedia.org/wiki/Convention_over_Configuration">Convention-over-Configuration</a> approach. Although PROV-JSON will offer flexibility in extending the core specification to accommodate application-specific requirements, it is possible to produce simple PROV-JSON structures without unnecessary overhead, such as namespace declarations.</li>
</ul>


<section> 
<h3>Structure of this Document</h3>

<p><a href="#data-typing">Section 2</a> describes the convention for encoding typed values in PROV-JSON.</p>

<p><a href="#prov-json-representation">Section 3</a> specifies the JSON encoding for all PROV-DM records.</p>

<p>Finally, <a href="#extensibility-section">Section 4</a> summarizes PROV-JSON's extensibility points.</p>

<p>In addition, <a href="#prov-json-example">Appendix A</a> provides a PROV-JSON example representation encoding <a href="http://www.w3.org/TR/2011/prov-dm/#prov-dm-example">the PROV-DM's File Scenario</a>.</p>

</section> 

<section id="prov-dm-namespace">
<h3>Namespace</h3>

<p>All the elements, relations, reserved names and attributes used in this specification belong to the PROV-DM namespace, which is <span class="name">http://www.w3.org/ns/prov-dm/</span> (TBC).</p>
</section>


<section>
<h3>Conventions</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[!RFC2119]].</p>
</section> 

</section> 

<section id="data-typing"> 

<h2>JSON Data Typing</h2>

<p>A JSON literal value is defined as being one of an object, array, number, string, boolean, or null. To allow for extra specificity, the data type of a literal in PROV-JSON may be provided using a 2-element array. The first element in this array is the literal value and the second element is the data type, given as a QName or URI. Null is not defined here: a null value should simply be omitted from the dictionary. Array is represented with the provjs:array type, discussed in the next section.</p>

<p>The following mappings apply for the default JSON types.</p>

<dl>
<dt>number</dt>
<dd>xsd:decimal</dd>
<dt>string</dt>
<dd>xsd:string</dd>
<dt>boolean</dt>
<dd>xsd:boolean</dd>
<dt>array</dt>
<dd>List of <a href="#multiple-value-properties">multiple values</a> of a property.</dd>
</dl>

<pre class="example">
    "prefix": {
        "x": "http://example.org/",
        "xsd": "http://www.w3.org/2001/XMLSchema-datatypes#"
    },
    ...
    "entity": {
        "e1": {
            "x:byteSize": "1034^^xsd:positiveInteger",
            "x:compression": "82.5e-2^^xsd:double",
            "x:content": "Y29udGVudCBoZXJl^^xsd:base64Binary",
        }
    }
</pre>

<p>If the data type is derived from one of the above mappings then the literal value may be kept in its original form. If the value is written as a string, it is the responsibility of the implementation to parse it correctly according to its type. The following example shows four representations of the same value: one as a JSON literal; one as a JSON literal with the type explicitly stated; one as a string literal (thus requiring parsing by the implementation); and one with a custom type which will also be delegated to the implementation.</p>

<pre class="example">
    "entity": {
        "e1": {
            "x:visible": true,
            "x:enabled": "true^^xsd:boolean",
            "x:custom": "true^^ex:customBoolean",
        }
    }
</pre>


<div class='note'>How to represent objects in PROV-JSON is being under consideration. In the next version, PROV-JSON will possibly support serializing typed objects either in an application-specific encoding or as native JSON objects with type information.</div>

<h3 id="multiple-value-properties">Properties with multiple values</h3>

<p>Some keys in PROV-JSON may have more than one value. To provide an array structure with the data typing approach above, we support the use of 'provjs:array' as a data type in the second element of a PROV-JSON literal. It is represented as a JSON array containing a combination of literals and literal/type pairs. For example:</p>

<pre class="example">
    "entity": {
        "e1": {
            "x:values": ["1^^xsd:integer", 2, "1034^^xsd:positiveInteger", "82.5^^xsd:decimal", "Y29udGBudCBoZXJl^^xsd:base64Binary"]
        }
    }
</pre>

</section>


<section id="prov-json-representation"> 

<h2>Representing the Provenance Data Model in JSON</h2>

<p>This section defines the JSON serialization mappings for PROV-DM records. The mappings are presented in the forms of examples with the intention of facilitating the use of PROV-JSON. A <a href="prov-json-schema.js">schema for PROV-JSON</a>, however, is also provided for the purpose of validating PROV-JSON documents (following the schema language in [[JSON-SCHEMA]]).</p>

<section id="PROV-JSON-overview"> 
      
<h3>Overview</h3>

<p>A <span class="nonterminal">bundle</span> (see section <a href="#RecordContainer">Bundle</a>) is used to wrap PROV-DM assertions and facilitate their interchange. In PROV-JSON, it is represented in one JSON structure:</p>

<div class="grammar"><pre>
{
    "entity": { <span class="code-comment">// Map of entities by entities' IDs</span>
    },
    "activity": { <span class="code-comment">// Map of activities by IDs</span>
    },
    "note": { <span class="code-comment">// Map of notes by IDs</span>
    },
    &lt;<i>relationName</i>&gt;: { <span class="code-comment">// A map of relations of type <i>relationName</i> by their IDs</span>
    },
    ...
    "bundle": { <span class="code-comment">// Map of named bundles by IDs</span>
    }
}
</pre></div>

<p>In addition, the top-level container contains an additional object called <span class="name">prefix</span> that defines all namespaces referred in the document.</p>

<div class="grammar"><pre>
{
    "prefix": {
        "default": "http://www.w3.org/ns/prov-dm/",
        ...
    },
    ...
}
</pre></div>

<p>The following sections define how each PROV-DM record is represented in PROV-JSON.</p>

</section>

<section id="record-element"> 
<h3>Element</h3>

<p>This section describes the JSON representations for all <a href="http://www.w3.org/TR/2011/prov-dm/#record-element">PROV-DM elements</a>: <span class="nonterminal">entityRecord</span>, <span class="nonterminal">activityRecord</span>, <span class="nonterminal">agentRecord</span>, and <span class="nonterminal">noteRecord</span>. In the container to which these elements belong, they are put in separate structures whose names are <span class="name">entity</span>, <span class="name">activity</span>, <span class="name">agent</span>, and <span class="name">note</span>, respectively.</p>


<section id="record-Entity"> 
      
<h4>Entity Record</h4>

<p>In PROV-JSON, each <a href="http://www.w3.org/TR/2011/prov-dm/#record-Entity">entity</a> is represented as a property in the <span class="nonterminal">entity</span> object, identified by the entity's <span class="name">id. The</span> property's value itself is an object structure containing the entity's attribute-values pairs.</p>

The following entity assertion, for example,
<pre class="example">
entity(e0, [ prov:type="File", ex:path="/shared/crime.txt", ex:creator="Alice" ])
</pre>
is serialized into the following structure
<pre class="example">
    ...
    "entity": {
        "e0": {
            "prov:type" "File",
            "ex:path": "/shared/crime.txt",
            "ex:creator": "Alice"
        }
    },
    ...
</pre>

<div class="note">In the example above, since <span class="name">type</span> is a term belonging to the <a href="#prov-dm-namespace">PROV-DM namespace</a>, the use of a prefix is not required. See Section <a href="#RecordContainer">Record Container</a> for details on how to use prefixes and namespaces.</div>

</section> 

<section id="record-Activity"> 
<h3>Activity Record</h3>

<p>Each <a href="http://www.w3.org/TR/2011/prov-dm/#record-Activity">Activity</a> is represented as a property in the <span class="name">activity</span> object identified by the Activity's <span class="name">id</span>. The property's value itself is an object structure containing the Activity's properties and its other attribute-values pairs.</p>

<p>
The following Activity assertion, for example,</p>
<pre class="example">activity(a1,add-crime-in-london,2011-11-16T16:05:00,2011-11-16T16:06:00,[ex:host="server.example.org",prov:type="ex:edit" %% xsd:QName])</pre>
<p>is serialized into:</p>
<pre class="example">
    ...
    "activity": {
        "a1": {
            "recipeLink": "add-crime-in-london",
            "startTime": ["2011-11-16T16:05:00", "xsd:dateTime"],
            "endTime": ["2011-11-16T16:06:00", "xsd:dateTime"],
            "ex:host": "server.example.org",
            "prov:type": ["ex:edit", "xsd:QName"]
        }
    },
    ...
</pre>
<div class="note">Extra attribute-value pairs of an activity record are put at the same level with other properties in an activity JSON structure.</div>

<p>The values of <span class="nonterminal">startTime</span> and <span class="nonterminal">endTime</span> MUST conform to xsd:dateTime [[!XMLSCHEMA-2]].</p>
</section> 

<section id="record-Agent">
<h3>Agent Record</h3>

<p>In PROV-DM, an <a href="http://www.w3.org/TR/2011/prov-dm/#record-Agent">agent</a> is a representation of an entity capable of activity. It can be of the following types <span class="name">prov:Person</span>, <span class="name">prov:Organization</span>, or <span class="name">prov:SoftwareAgent</span>, which are subclasses of <span class="name">prov:Agent</span>. Hence, in PROV-JSON, an agent record is encoded as an <a href="#record-Entity">entity</a> but with an extra <span class="name">prov:type</span> attribute to indicate that it is an agent, i.e. <span class="name">"prov:type": ["prov:Agent", "xsd:QName"]</span>.

<pre class="example">
agent(e1, [ex:employee="1234" %% xsd:integer, ex:name="Alice", prov:type="prov:Person" %% xsd:QName])
</pre>
is encoded into:
<pre class="example">
    ...
    "entity": {
        "e1": {
            "ex:employee": [1234, "xsd:integer"],
            "ex:name": "Alice",
            "prov:type": [["prov:Person", "xsd:QName"], ["prov:Agent", "xsd:QName"], "provjs:array"]
        }
        ...
    },
    ...
</pre>
<div class="note"> Can we always expect the value of a <span class="name">type</span> property to be a URI?</div>
</section>

<section id="record-note"> 
      
<h4>Note Record</h4>

<p>In PROV-DM, a <a href="http://www.w3.org/TR/2011/prov-dm/#record-note">note</a> is a set of name-value pairs, whose meaning is application specific. It is represented in PROV-JSON as a property of the <span class="name">note</span> object, identified by the note's <span class="name">id</span>. The property's value itself is an object structure containing the note's attribute-values pairs.</p> 

<p>
The following note record, for example,</p>
<pre class="example">
note(ann1,[ex:color="blue", ex:screenX="20" %% xsd:integer, ex:screenY="30" %% xsd:integer])
</pre>
<p>is encoded in PROV-JSON as follows.</p>
<pre class="example">
    ...
    "note": {
        "ann1": {
            "ex:color": "blue",
            "ex:screenX": [20, "xsd:integer"],
            "ex:screenY": [30, "xsd:integer"]
        }
    }
    ...
</pre>

</section> 

</section>


<section id="record-relation">
<h3>Relation</h3>

<p>This section specifies how various <a href="http://www.w3.org/TR/2011/prov-dm/#record-relation">relation records</a> in PROV-DM are serialized in PROV-JSON.</p>

<p>In general, a <span class="nonterminal">relationRecord</span> has the following construct:</p>

<div class='grammar'>
<span class="nonterminal">relationRecord</span>&nbsp;:=  
<span class="nonterminal">relationName</span>
(<span class="nonterminal">identifier1</span>,
<span class="nonterminal">identifier2</span>,
[<span class="nonterminal">additionalProperties</span>],
[<span class="nonterminal">qualifiers</span>])
<br/>
</div>
<p>where <span class="nonterminal">identifier1</span> and <span class="nonterminal">identifier2</span> are identifiers to PROV-DM elements</p>
Relations are grouped by <span class="nonterminal">relationName</span> in a PROV-JSON structure.
<div class="grammar"><pre>
    ...
    "notes": { ... },
    <i>relationName</i>: {
        <span class="code-comment">// relationName(identifier1, identifier2, ...)</span>
        <i>relationID</i>: {
            <i>attribute1</i>: <em>identifier1</em>,
            <i>attribute2</i>: <em>identifier2</em>,
                ...
        },
        <span class="code-comment">// More relationID,identifier1,identifier2 structures here if there are more instances of relationName(...)</span>
    },
    <i>otherRelationName</i>: {
        ...
    },
    ...
</pre></div>
Any values of <span class="nonterminal">additionalProperties</span> and <span class="nonterminal">qualifiers</span> are specified alongside the identifier pairs in above structure.

<p>Since identifiers of relations are optional in PROV-DM, there may be cases where <span class="nonterminal">relationID</span>s are missing. However, they are still required in order to maintain the validity of a PROV-JSON structure. In such cases, it is up to the serialization algorithm to generate a valid identifier for <span class="nonterminal">relationID</span> that is unique internally to a PROV-JSON serialization. For example, the <a href="http://www.w3.org/TeamSubmission/turtle/#nodeID">nodeID production in Turtle</a> may be used for this purpose, e.g. <code>_:A1</code>.</p>

<p>The following sections provide more details on how each type of relation is serialized via typical examples.</p>


<section id="record-Generation">
<h4>Generation Record</h4>

<p>The following <a href="http://www.w3.org/TR/2011/prov-dm/#record-Generation">generation assertions</a></p>
<pre class="example">
  wasGeneratedBy(e1,a1, 2001-10-26T21:32:52, [ex:port="p1", ex:order=1])
  wasGeneratedBy(e2,a1, 2001-10-26T10:00:00, [ex:port="p1", ex:order=2])
</pre>
<p>are serialized as follows.</p>
<pre class="example">
{
    ...
    "wasGeneratedBy": {
        "_:wBG1": {
            "prov:activity": "a1",
            "prov:entity": "e1",
            "ex:port": "p1",
            "ex:order": [1, "xsd:integer"],
            "prov:time":  ["2001-10-26T21:32:52", "xsd:dateTime"]
        },
        "_:wBG2": {
            "prov:activity": "a1",
            "prov:entity": "e2",
            "ex:port": "p1",
            "ex:order": [2, "xsd:integer"],
            "prov:time":  ["2001-10-26T10:00:00", "xsd:dateTime"]
        },
    },
    ...
}
</pre>
Note that, in the example above, the qualifier's components are unbundled and mixed alongside with the relation's other properties (i.e. <span class="name">time</span>) in the relation's object.
</section>


<section id="record-Usage">
<h3>Usage Record</h3>

<p>The following <a href="http://www.w3.org/TR/2011/prov-dm/#record-Usage">usage records</a></p>
<pre class="example">
  used(a1,e1,2011-11-16T16:00:00,[ex:parameter="p1"])
  used(a1,e2,2011-11-16T16:00:01,[ex:parameter="p2"])
</pre>
<p>are serialized in to PROV-JSON as follows.</p>
<pre class="example">
{
    ...
    "used": {
        "_:u1": {
            "prov:entity": "e1",
            "prov:activity": "a1",
            "ex:parameter": "p1",
            "prov:time": ["2011-11-16T16:00:00", "xsd:dateTime"]
        },
        "_:u2": {
            "prov:entity": "e2",
            "prov:activity": "a1",
            "ex:parameter": "p2",
            "prov:time": ["2011-11-16T16:00:01", "xsd:dateTime"]
        },
    },
    ...
}
</pre>

</section>

<section id="record-ActivityAssociation">
<h3>Activity Association Record</h3>


<p>The following <a href="http://www.w3.org/TR/2011/prov-dm/#record-ActivityAssociation"> activity association records,</a></p>
<pre class="example">
  activity(a,[prov:type="workflow"])
  agent(ag1,[prov:type="programmer"]
  agent(ag2,[prov:type="researcher"]
  wasAssociatedWith(a,ag1,[prov:role="loggedInUser", ex:how="webapp"])
  wasAssociatedWith(a,ag2,[prov:role="designer", ex:context="phd"])
</pre>
<p>are serialized into:</p>
<pre class="example">
{
    ...
    "entity": {
        "ag1": {
            "prov:type": ["programmer", ["prov:Agent", "xsd:QName"], "provjs:array"]
        },
        "ag2": {
            "prov:type": ["researcher", ["prov:Agent", "xsd:QName"], "provjs:array"]
        }
    },
    "activity": {
        "a": {
            "prov:type" "workflow"
        }
    },
    "wasAssociatedWith": {
        "_:wAW1": {
            "prov:activity": "a",
            "prov:agent": "ag1",
            "prov:role": "loggedInUser",
            "ex:how": "webapp"
        },
        "_:wAW2": {
            "prov:activity": "a",
            "prov:agent": "ag2",
            "prov:role": "designer",
            "ex:context": "phd"
        }
    },
    ...
}
</pre>
</section>

<section id="record-Start-End">
<h3>Start and End Records</h3>

The <a href="http://www.w3.org/TR/2011/prov-dm/#record-Start-End">start and end records</a> below
<pre class="example">
  wasStartedBy(a,ag,[ex:mode="manual"])
  wasEndedby(a,ag,[ex:mode="manual"])
</pre>
<p>are serialized into:</p>
<pre class="example">
{
    ...
    "wasStartedBy": {
        "_:wSB1": {
            "prov:activity": "a",
            "prov:agent": "ag",
            "ex:mode": "manual"
        }
    },
    "wasEndedBy": {
        "_:wEB1": {
            "prov:activity": "a",
            "prov:agent": "ag",
            "ex:mode": "manual"
        }
    },
    ...
}
</pre>

</section>

<section id="record-responsibility">
<h3>Responsibility Record</h3>

The <a href="http://www.w3.org/TR/2011/prov-dm/#record-responsibility">responsibility records</a> below
<pre class="example">
  activity(a,[prov:type="workflow"])
  agent(ag1,[prov:type="programmer"]
  agent(ag2,[prov:type="researcher"]
  agent(ag3,[prov:type="funder"]
  wasAssociatedWith(a,ag1,[prov:role="loggedInUser"])
  wasAssociatedWith(a,ag2)
  actedOnBehalfOf(ag1,ag2,a,[prov:type="delegation"])
  actedOnBehalfOf(ag2,ag3,a,[prov:type="contract"])
</pre>
<p>are serialized into:</p>
<pre class="example">
{
    ...
    "entity": {
        "ag1": {
            "prov:type": ["programmer", ["prov:Agent", "xsd:QName"], "provjs:array"]
        },
        "ag2": {
            "prov:type": ["researcher", ["prov:Agent", "xsd:QName"], "provjs:array"]
        },
        "ag3": {
            "prov:type": ["funder", ["prov:Agent", "xsd:QName"], "provjs:array"]
        }
    },
    "activity": {
        "a": {
            "prov:type": "workflow"
        }
    },
    "wasAssociatedWith": {
        "_:wAW1": {
            "prov:activity": "a",
            "prov:agent": "ag1",
            "prov:role": "loggedInUser"
        },
        "_:wAW2": {
            "prov:activity": "a",
            "prov:agent": "ag2"
        }
    },
    "actedOnBehalfOf": {
        "_:aOBO1": {
            "prov:subordinate": "ag1",
            "prov:responsible": "ag2",
            "prov:activity": "a",
            "prov:type": "delegation"
        },
        "_:aOBO2": {
            "prov:subordinate": "ag2",
            "prov:responsible": "ag3",
            "prov:activity": "a",
            "prov:type": "contract"
        }
    },
    ...
}
</pre>

</section>

<section id="record-Derivation">
<h3>Derivation Record</h3>


<p>The following <a href="http://www.w3.org/TR/2011/prov-dm/#record-Derivation">derivation assertions</a></p>
<pre class="example">
  wasDerivedFrom(e5,e3,a4,g2,u2)
  wasDerivedFrom(e3,e2)
  wasBasedOn(e2,e1)
</pre>
<p>are represented in PROV-JSON as follows.</p>
<pre class="example">
{
    ...
    "wasDerivedFrom": {
        "_:wDF1": {
            "prov:generatedEntity": "e3",
            "prov:usedEntity": "e2"
        },
        "_:wDF2": {
            "prov:generatedEntity": "e5",
            "prov:usedEntity": "e3",
            "prov:activity": "a4",
            "prov:generation": "g2",
            "prov:usage": "u2"
        }
    },
    "wasBasedOn": {
        "_:wBF1": {
            "prov:generatedEntity": "e2",
            "prov:usedEntity": "e1"
        }
    },
    ...
}
</pre>

</section>

<section id="record-complement-of">

<h3>Complementarity Record</h3>

<p>The <a href="http://www.w3.org/TR/2011/prov-dm/#record-complement-of">complementarity records</a> below</p>
<pre class="example">
  entity(rs,[ex:created="1870" %% xsd:integer])

  entity(rs_l1,[prov:location="loc2"])
  entity(rs_l2,[prov:location="The Mall"])

  entity(rs_m1,[ex:membership="250" %% xsd:integer, ex:year="1900" %% xsd:integer])
  entity(rs_m2,[ex:membership="300" %% xsd:integer, ex:year="1945" %% xsd:integer])
  entity(rs_m3,[ex:membership="270" %% xsd:integer, ex:year="2010" %% xsd:integer])

  wasComplementOf(rs_m3, rs_l2)
  wasComplementOf(rs_m2, rs_l1)
  wasComplementOf(rs_m2, rs_l2)
  wasComplementOf(rs_m1, rs_l1)

  wasComplementOf(rs_m3, rs)
  wasComplementOf(rs_m2, rs)
  wasComplementOf(rs_m1, rs)
  wasComplementOf(rs_l1, rs)
  wasComplementOf(rs_l2, rs)

</pre>
<p>are serialized into:</p>
<pre class="example">
{
    ...
    "entity": {
        "rs": {
            "ex:created": [1870, "xsd:integer"]
        },
        "rs_l1": {
            "location": "loc2"
        },
        "rs_l2": {
            "location": "The Mall"
        },
        "rs_m1": {
            "ex:membership": [250, "xsd:integer"],
            "ex:year": [1900, "xsd:integer"]
        },
        "rs_m2": {
            "ex:membership": [300, "xsd:integer"],
            "ex:year": [1945, "xsd:integer"]
        },
        "rs_m3": {
            "ex:membership": [270, "xsd:integer"],
            "ex:year": [2010, "xsd:integer"]
        },
    },
    "wasComplementOf": {
        "_:wCO1": {
            "prov:subject": "rs_m3",
            "prov:alternate": "as_l2"
        },
        "_:wCO2": {
            "prov:subject": "rs_m2",
            "prov:alternate": "as_l1"
        },
        "_:wCO3": {
            "prov:subject": "rs_m2",
            "prov:alternate": "as_l2"
        },
        "_:wCO4": {
            "prov:subject": "rs_m1",
            "prov:alternate": "as_l1"
        },
        "_:wCO5": {
            "prov:subject": "rs_m3",
            "prov:alternate": "rs"
        },
        "_:wCO6": {
            "prov:subject": "rs_m2",
            "prov:alternate": "rs"
        },
        "_:wCO7": {
            "prov:subject": "rs_m1",
            "prov:alternate": "rs"
        },
        "_:wCO8": {
            "prov:subject": "rs_l1",
            "prov:alternate": "rs"
        },
        "_:wCO9": {
            "prov:subject": "rs_l2",
            "prov:alternate": "rs"
        },
    },
    ...
}
</pre>

</section>


<section id="record-annotation">
<h4>Annotation Record</h4>

<p>An <a href="http://www.w3.org/TR/2011/prov-dm/#record-annotation">annotation record</a> establishes a link between an identifiable PROV-DM record and a note record referred to by its identifier. Multiple note records can be associated with a given PROV-DM record; symmetrically, multiple PROV-DM records can be associated with a given note record. Since note records have identifiers, they can also be annotated.</p> 

<p>
The following records, for example,</p>
<pre class="example">
  entity(e1,[prov:type="document"])
  entity(e2,[prov:type="document"])
  activity(a,transform,t1,t2,[])
  used(u1,a,e1,[ex:file="stdin"])
  wasGeneratedBy(e2, a, [ex:file="stdout"])

  note(n1,[ex:icon="doc.png"])
  hasAnnotation(e1,n1)
  hasAnnotation(e2,n1)

  note(n2,[ex:style="dotted"])
  hasAnnotation(u1,n2)
</pre>
<p>are serialized into:</p>
<pre class="example">
{
    ...
    "entity": {
        "e1": {
            "prov:type": "document"
        },
        "e2": {
            "prov:type": "document"
        }
    },
    "activity": {
        "a": {
            "prov:recipeLink": "transform",
            "prov:startTime": "t1",
            "prov:endTime": "t2",
        },
    },
    "note": {
        "n1": {
            "ex:icon": "doc.png"
        },
        "n2": {
            "ex:style": "dotted"
        },
    },
    "hasAnnotation": {
        "_:hA1": {
            "prov:record": "e1",
            "prov:note": "n1"
        },
        "_:hA2": {
            "prov:record": "e2",
            "prov:note": "n1"
        },
        "_:hA3": {
            "prov:record": "u1",
            "prov:note": "n2"
        },
    }
    "wasGeneratedBy": {
        "_:wGB1": {
            "prov:entity": "e2",
            "prov:activity": "a",
            "ex:file": "stdout"
        }
    },
    "used": {
        "u1": {
            "prov:entity": "e1",
            "prov:activity": "a",
            "ex:file": "stdin",
        }
    }
    ...
}
</pre>


</section>
</section>

<section  id="bundle">
<h3>Bundles</h3>

In this section, the PROV-JSON representations for the two PROV-DM's bundling constructs are introduced, i.e., a <span class="nonterminal">bundle</span>  and a <span class="nonterminal">named bundle</span>.

<section id="RecordContainer">
<h4>Bundle</h4>

<p>A <a href="http://www.w3.org/TR/2011/prov-dm/#RecordContainer">provenance container</a> is a house-keeping construct of PROV-DM used for bundling PROV-DM assertions. A PROV-JSON serialization represents an instance of bundle. This is the outermost level of a PROV-JSON structure. In addition to the top-level JSON structures like <span class="name">entity</span>, <span class="name">activity</span>, <span class="name">agent</span>, etc., particular namespaces used in a PROV-JSON structure can be declared in a <span class="name">prefix</span> structure (see an example below). Prefixes can then be used to bind terms to specific namespaces. There is a special prefix called <code>default</code>, which can be used to declare the default namespace to which all unprefixed terms will be bound.</p>

<p><strong>Default prefixes</strong>: By default, the following prefixes are implicitly defined:</p>
<ul>
  <li><code>prov</code>: <span class="name">http://www.w3.org/ns/prov/#</span> (i.e. <a href="#prov-dm-namespace">PROV-DM namespace</a>)</li>
  <li><code>xsd</code>: <span class="name">http://www.w3.org/2001/XMLSchema-datatypes</span> (i.e. XML Datatypes [[!XMLSCHEMA-2]])</li>
</ul>
<p>Therefore, terms that are prefixed with <code>prov:</code> or <code>xsd:</code> will be implicitly bound to the relevant namespaces without the need for their explicit declarations. In addition, the <code>default</code> prefix is implicitly defined to be <code>prov</code>. As a result, terms in the PROV-DM namespace can be written either with or without the <code>prov</code> prefix, <strong>unless</strong> a different default namespace is explicitly defined (in which case, only the former can be used).</p>

<p>
The following container </p>
<pre class="example">
container([x http://example.org/], [acc1,acc2]
          account(acc1,http://example.org/asserter1,...)
          account(acc2,http://example.org/asserter1,...))
</pre>
<p> is represented as follows in PROV-JSON.</p>
<pre class="example">
{
    "prefix": {
        "x": "http://example.org/"
    },
    ...
    "bundle": {
        "acc1": {
            "prov:asserter": "http://example.org/asserter1",
            ...
        },
        "acc2": {
            "prov:asserter": "http://example.org/asserter2",
            ...
        }
    }
}
</pre>

</section>


<section id="record-Account">
<h3>Account Record</h3>

<p>In PROV-DM, an <a href="http://www.w3.org/TR/2011/prov-dm/#record-Account">account record</a> is a wrapper of records with a dual purpose:  </p> 
<ul>
<li> It is the mechanism by which attribution of provenance can be asserted; it allows asserters to bundle up their assertions, and assert suitable attribution;
<li> It provides a scoping mechanism for record identifiers and for some constraints.</li>
</ul>


<p> An account is in PROV-DM is serialized into an object in the <span class="name">account</span> structure in a PROV-JSON representation. The following account record, for example,</p>
<pre class="example">
  account(acc0,
        http://example.org/asserter, 
          entity(e0, [ prov:type="File", ex:path="/shared/crime.txt", ex:creator="Alice" ])
          ...
          wasDerivedFrom(e2,e1)
          ...
          activity(a0,create-file,t)
          ...
          wasGeneratedBy(e0,a0,[])     
          ...
          wasAssociatedWith(a4, ag5, [prov:role="communicator"])  )
</pre>
<p>is encoded as:</p>
<pre class="example">
{
    ...
    "account": {
        "acc0": {
            "prov:asserter": "http://example.org/asserter",
            <span class="code-comment">// The remaining records of acc0 are encoded as specified in the previous sections</span>
            "entity": { ... },
            "activity": { ... },
            "note": { ... },
            "wasAssociatedWith": { ... },
            "wasDerivedFrom": { ... },
            "wasGeneratedBy": { ... },
            "account": { ... }
        }
    }
}
</pre>

<p>PROV-DM allows an account to be nested in another account. The following example shows account <span class="name">acc3</span> contains a nested account <span class="name">acc4</span>.</p>
<pre class="example">
  account(acc3,
        http://example.org/asserter1, 
          entity(e0, [ prov:type="File", ex:path="/shared/crime.txt", ex:creator="Alice" ])
          activity(a0,create-file,t)
          wasGeneratedBy(e0,a0,[])  
          account(acc4,
                 http://example.org/asserter2,
                 entity(e1, [ prov:type="File", ex:path="/shared/crime.txt", ex:creator="Alice", ex:content="" ])
                 activity(a0,copy-file,t)
                 wasGeneratedBy(e1,a0,[ex:fct="create"])
                 wasComplementOf(e1,e0)))</pre>
<p>In PROV-JSON, the nested account, e.g. <span class="name">acc4</span>, can be encoded into one account object in its parent account, i.e. <span class="name">acc3</span>, as below.</p>

<pre class="example">
{
    ...
    "account": {
        "acc3": {
            "prov:asserter": "http://example.org/asserter1",
            <span class="code-comment">// The remaining records of acc3</span>
            ...,
            "account": {
                "acc4": {
                    "prov:asserter": "http://example.org/asserter2",
                    <span class="code-comment">// The remaining records of acc4</span>
                    ...
                }
            }
        }
    }
}
</pre>

</section>
</section>

<section id="extensibility-identifiers"> 
<h3>Identifiers</h3>

<p>An identifier in PROV-JSON (and in <a href="http://www.w3.org/TR/2011/prov-dm/#record-identifier">PROV-DM</a>) is a qualified name.</p>

<div class="note">It is possible that there are two (or more) qualified names that resolves to the same IRI. PROV-JSON makes no provision to ensure that records referred by equivalent identifiers will be merged. It is the responsibility of the application consuming PROV-JSON to deal with such cases properly. However, it is recommended that applications producing PROV-JSON to make an effort to prevent those cases from occurring.</div>
</section>

</section>

<section id="extensibility-section"> 
<h2>Extensibility Points</h2>

<p>Since the PROV-JSON representation was developed to represent PROV-DM, it supports the <a href="http://www.w3.org/TR/2011/prov-dm/#extensibility-section">extensibility points</a> provided by PROV-DM, allowing designers to specialize it to specific applications or domains. We summarize these extensibility points here:

<ul>
<li> Applications are free to introduce application-specific attributes. They can be distinguished by qualifying them with a prefix denoting a namespace declared in a <a href="#RecordContainer">namespace declaration</a>. </li>

<li>Note records allow arbitrary metadata to be associated with identifiable records of PROV-DM. Note records consist of name-value pairs. Like attributes, names are qualified by a namespace.</li>

<li>Namespaces allow attributes and names to be qualified. </li>

<li>Subtyping is allowed by means of the reserved attribute <span class="name">type</span>.</li>

<li>Domain specific values can be expressed by means of <a href="#data-typing">typed literals</a>. </li>
</ul>


</section> 

<section id="prov-json-example" class="appendix"> 
<h2>PROV-JSON Serialization Example</h2>

In order to illustrate the use of PROV-JSON in a real-world scenario, this section provides the PROV-JSON representation for the <a href="http://www.w3.org/TR/2011/prov-dm/#prov-dm-example">File Scenario</a> given in the [[PROV-DM]] as an example.

<section> 
<h3>A File Scenario</h3>

<p>This scenario is concerned with the evolution of a crime statistics file (referred to as e0) stored on a shared file system and which journalists Alice, Bob, Charles, David, and Edith can share and edit. We consider various events in the evolution of file e0; events listed below follow each other, unless otherwise specified.</p>

<p>Event evt1: Alice creates (a0) an empty file in /share/crime.txt.  We denote this e1.</p>

<p>Event evt2: Bob appends (a1) the following line to /share/crime.txt:</p>
<pre>
There was a lot of crime in London last month.
</pre>
<p>We denote this e2.</p>

<p>Event evt3: Charles emails (a2) the contents of /share/crime.txt, as an attachment, which we refer to as e4. (We specifically refer to a copy of the file that is uploaded on the mail server.)</p>

<p>Event evt4: David edits (a3) file /share/crime.txt as follows.</p>
<pre>
There was a lot of crime in London and New-York last month.
</pre>
<p>We denote this e3.</p>

<p>Event evt5: Edith emails (a4) the contents of /share/crime.txt as an attachment, referred to as e5.</p>

<p>Event evt6: between events evt4 and evt5, someone (unspecified) runs a spell checker (a5) on the file /share/crime.txt. The file after spell checking is referred to as e6.</p>

</section> 

<section id="example-prov-json-encoding"> 
<h3>Encoding using PROV-JSON</h3>

In this section, provenance assertions in the file scenario above (see [[PROV-DM]] for explanation of those assertions) are encoded into a PROV-JSON representation (following the mappings specified in Section <a href="#prov-json-representation">Representing the Provenance Data Model in JSON</a> above).
<p>
<a href="http://www.w3.org/TR/2011/prov-dm/#record-Entity">Entity Records</a>: The file in its various forms and its copies are modelled as entity records, corresponding to multiple characterizations, as per scenario. The entity records are identified by  <span class="name">e0</span>, ..., <span class="name">e6</span>.</p>
<pre>
{
    <span class="code-new">"prefix": {
        <span class="code-comment">// Only the prefix "ex" needs to be defined. "prov" is the default namespace.</span>
        "ex": "www.example.com"
    },
    "entity": {
        <span class="code-comment">// entity(e0, [ prov:type="File", ex:path="/shared/crime.txt", ex:creator="Alice" ])</span>
        "e0": {
            "prov:type" "File",
            "ex:path": "/shared/crime.txt",
            "ex:creator": "Alice"
        },
        <span class="code-comment">// entity(e1, [ prov:type="File", ex:path="/shared/crime.txt", ex:creator="Alice", ex:content="" ])</span>
        "e1": {
            "prov:type" "File",
            "ex:path": "/shared/crime.txt",
            "ex:creator": "Alice",
            "ex:content": ""
        },
        <span class="code-comment">// entity(e2, [ prov:type="File", ex:path="/shared/crime.txt", ex:creator="Alice", ex:content="There was a lot of crime in London last month."])</span>
        "e2": {
            "prov:type" "File",
            "ex:path": "/shared/crime.txt",
            "ex:creator": "Alice",
            "ex:content": "There was a lot of crime in London last month."
        },
        <span class="code-comment">// entity(e3, [ prov:type="File", ex:path="/shared/crime.txt", ex:creator="Alice", ex:content="There was a lot of crime in London and New York last month."])</span>
        "e3": {
            "prov:type" "File",
            "ex:path": "/shared/crime.txt",
            "ex:creator": "Alice",
            "ex:content": "There was a lot of crime in London and New York last month."
        },
        <span class="code-comment">// entity(e4, [ ])</span>
        "e4": {
        },
        <span class="code-comment">// entity(e5, [ ])</span>
        "e5": {
        },
        <span class="code-comment">// entity(e6, [ prov:type="File", ex:path="/shared/crime.txt", ex:creator="Alice", ex:content="There was a lot of crime in London and New York last month.", ex:spellchecked="yes"])</span>
        "e6": {
            "prov:type" "File",
            "ex:path": "/shared/crime.txt",
            "ex:creator": "Alice",
            "ex:content": "There was a lot of crime in London and New York last month.",
            "ex:spellchecked": "yes"
        }
    },</span>
    ...
}
</pre>

<p>
<a href="http://www.w3.org/TR/2011/prov-dm/#record-Activity">Activity Records</a> represent activities in the scenario.</p>

<pre>
{
    ...
    <span class="code-new">"activity": {
        <span class="code-comment">// activity(a0, create-file, 2011-11-16T16:00:00,,[])</span>
        "a0" : {
            "recipeLink": "create-file",
            "startTime": ["2011-11-16T16:00:00", "xsd:dateTime"]
        },
        <span class="code-comment">// activity(a1, add-crime-in-london, 2011-11-16T16:05:00,,[])</span>
        "a1" : {
            "recipeLink": "add-crime-in-london",
            "startTime": ["2011-11-16T16:05:00", "xsd:dateTime"]
        },
        <span class="code-comment">// activity(a2, email, 2011-11-16T17:00:00,,[])</span>
        "a2" : {
            "recipeLink": "email",
            "startTime": ["2011-11-16T17:00:00", "xsd:dateTime"]
        },
        <span class="code-comment">// activity(a3, edit-London-New-York, 2011-11-17T09:00:00,,[])</span>
        "a3" : {
            "recipeLink": "edit-London-New-York",
            "startTime": ["2011-11-17T09:00:00", "xsd:dateTime"]
        },
        <span class="code-comment">// activity(a4, email, 2011-11-17T09:30:00,,[])</span>
        "a4" : {
            "recipeLink": "email",
            "startTime": ["2011-11-17T09:30:00", "xsd:dateTime"]
        },
        <span class="code-comment">// activity(a5, spellcheck,,,[])</span>
        "a5" : {
            "recipeLink": "spellcheck"
        },
    },</span>
    ...
}
</pre>

<p>
<a href="http://www.w3.org/TR/2011/prov-dm/#record-Generation">Generation Records</a> represent the event at which a file is created in a specific form. Attributes are used to describe the modalities according to which a given entity is generated by a given activity.  The interpretation of attributes is application specific. Illustrations of such attributes for the scenario are: no attribute is provided for <span class="name">e0</span>;
<span class="name">e2</span> was generated by the editor's  save function;  <span class="name">e4</span> can be found on the smtp port, in the attachment section of the mail message; <span class="name">e6</span> was produced on the standard output of <span class="name">a5</span>. Two identifiers <span class="name">g1</span> and <span class="name">g2</span> identify the generation records referenced in derivations introduced below.</p>

<pre>
{
    ...
    <span class="code-new">"wasGeneratedBy": {
        <span class="code-comment">// wasGeneratedBy(e0, a0, [])</span>
        "_:wGB1": {
            "activity": "a0",
            "entity": "e0"
        },
        <span class="code-comment">// wasGeneratedBy(e1, a0, [ex:fct="create"])</span>
        "_:wGB2": {
            "activity": "a0",
            "entity": "e1",
            "ex:fct": "create"
        },
        <span class="code-comment">// wasGeneratedBy(e2, a1, [ex:fct="save"])</span>
        "_:wGB3": {
            "activity": "a1",
            "entity": "e2",
            "ex:fct": "save"
        },
        <span class="code-comment">// wasGeneratedBy(e3, a3, [ex:fct="save"])</span>
        "_:wGB4": {
            "activity": "a3",
            "entity": "e3",
            "ex:fct": "save"
        },
        <span class="code-comment">// wasGeneratedBy(g1, e4, a2, [ex:port="smtp", ex:section="attachment"])</span>
        "g1": {
            "activity": "a2",
            "entity": "e4",
            "ex:port": "smtp",
            "ex:section": "attachment"
        },
        <span class="code-comment">// wasGeneratedBy(g2, e5, a4, [ex:port="smtp", ex:section="attachment"])</span>
        "g2": {
            "activity": "a4",
            "entity": "e5",
            "ex:port": "smtp",
            "ex:section": "attachment"
        },
        <span class="code-comment">// wasGeneratedBy(e6, a5, [ex:file="stdout"])</span>
        "_:wGB5": {
            "activity": "a5",
            "entity": "e6",
            "ex:file": "stdout"
        }
    },</span>
    ...
}
</pre>

<p>
<a href="http://www.w3.org/TR/2011/prov-dm/#record-Use">Used Records</a> represent the event by which a file is read by an activity. 

Likewise, attributes describe the modalities according to which the various entities are used by activities.  Illustrations of such attributes are: 
<span class="name">e1</span> is used in the context of  <span class="name">a1</span>'s <span class="name">load</span> functionality; <span class="name">e2</span> is used by <span class="name">a2</span> in the context of its attach functionality; <span class="name">e3</span> is used on the standard input by <span class="name">a5</span>. Two identifiers <span class="name">u1</span> and <span class="name">u2</span> identify the Usage records referenced in derivations introduced below.</p>

<pre>
{
    ...
    <span class="code-new">"used" : {
        <span class="code-comment">// used(a1,e1,[ex:fct="load"])</span>
        "_:u1": {
            "activity": "a1",
            "entity": "e1",
            "ex:fct": "load"
        },
        <span class="code-comment">// used(a3,e2,[ex:fct="load"])</span>
        "_:u2": {
            "activity": "a3",
            "entity": "e2",
            "ex:fct": "load"
        },
        <span class="code-comment">// used(u1,a2,e2,[ex:fct="attach"])</span>
        "u1": {
            "activity": "a2",
            "entity": "e2",
            "ex:fct": "attach"
        },
        <span class="code-comment">// used(u2,a4,e3,[ex:fct="attach"])</span>
        "u2": {
            "activity": "a4",
            "entity": "e3",
            "ex:fct": "attach"
        },
        <span class="code-comment">// used(a5,e3,[ex:file="stdin"])</span>
        "_:u3": {
            "activity": "a5",
            "entity": "e3",
            "ex:file": "stdin"
        }
    },</span>
    ...
}
</pre>

<p>
<a href="http://www.w3.org/TR/2011/prov-dm/#record-Derivation">Derivation Records</a> express that an entity is derived from another.  The first two are expressed in their compact version, whereas the following two are expressed in their full version, including the activity underpinning the derivation, and associated  usage (<span class="name">u1</span>, <span class="name">u2</span>) and generation (<span class="name">g1</span>, <span class="name">g2</span>) records.</p>

<pre>
{
    ...
    <span class="code-new">"wasDerivedFrom": {
        <span class="code-comment">// wasDerivedFrom(e2,e1)</span>
        "_:wDF1": {
            "generatedEntity": "e2",
            "usedEntity": "e1",
        },
        <span class="code-comment">// wasDerivedFrom(e3,e2)</span>
        "_:wDF2": {
            "generatedEntity": "e3",
            "usedEntity": "e2"
        },
        <span class="code-comment">// wasDerivedFrom(e4,e2,a2,g1,u2)</span>
        "_:wDF3": {
            "activity": "a2",
            "generatedEntity": "e4",
            "usedEntity": "e2",
            "generation": "g1",
            "usage": "u2"
        },
        <span class="code-comment">// wasDerivedFrom(e5,e3,a4,g2,u2)</span>
        "_:wDF4": {
            "activity": "a5"
            "generatedEntity": "e5",
            "usedEntity": "e3",
            "generation": "g2",
            "usage": "u2"
        }
    },</span>
    ...
}
</pre>

<p><a href="http://www.w3.org/TR/2011/prov-dm/#record-complement-of">wasComplementOf</a>: The crime statistics file (<span class="name">e0</span>) has various contents over its existence (<span class="name">e1</span>, <span class="name">e2</span>, <span class="name">e3</span>); the entity records identified by <span class="name">e1</span>, <span class="name">e2</span>, <span class="name">e3</span> complement <span class="name">e0</span> with an attribute <span class="name">content</span>. Likewise, the one denoted by <span class="name">e6</span> complements the record denoted by <span class="name">e3</span> with an attribute <span class="name">spellchecked</span>.</p>

<pre>
{
    ...
    <span class="code-new">"wasComplementOf": {
        <span class="code-comment">// wasComplementOf(e1,e0)</span>
        "_:wCO1": {
            "subject": e1,
            "alternate": e0
        },
        <span class="code-comment">// wasComplementOf(e2,e0)</span>
        "_:wCO2": {
            "subject": e2,
            "alternate": e0
        },
        <span class="code-comment">// wasComplementOf(e3,e0)</span>
        "_:wCO3": {
            "subject": e3,
            "alternate": e0
        },
        <span class="code-comment">// wasComplementOf(e6,e3)</span>
        "_:wCO3": {
            "subject": e6,
            "alternate": e3
        }</span>
    },
    ...
}
</pre>

<p>
<a href="http://www.w3.org/TR/2011/prov-dm/#record-Agent">Agent Records</a>: the various users are represented as agents, themselves being a type of entity.</p>

<pre>
{
    ...
    "entity": {
        <span class="code-new"><span class="code-comment">// agent(ag1, [ prov:type="prov:Person" %% xsd:QName, ex:name="Alice" ])</span>
        "ag1": {
            "prov:type" ["Person", "xsd:QName"],
            "ex:name": "Alice"
        },
        <span class="code-comment">// agent(ag2, [ prov:type="prov:Person" %% xsd:QName, ex:name="Bob" ])</span>
        "ag2": {
            "prov:type" ["Person", "xsd:QName"],
            "ex:name": "Bob"
        },
        <span class="code-comment">// agent(ag3, [ prov:type="prov:Person" %% xsd:QName, ex:name="Charles" ])</span>
        "ag3": {
            "prov:type" ["Person", "xsd:QName"],
            "ex:name": "Charles"
        },
        <span class="code-comment">// agent(ag4, [ prov:type="prov:Person" %% xsd:QName, ex:name="David" ])</span>
        "ag4": {
            "prov:type" ["Person", "xsd:QName"],
            "ex:name": "David"
        },
        <span class="code-comment">// agent(ag5, [ prov:type="prov:Person" %% xsd:QName, ex:name="Edith" ])</span>
        "ag5": {
            "prov:type" ["Person", "xsd:QName"],
            "ex:name": "Edith"
        },</span>
        ...
    },
    <span class="code-new">"agent": [
        "a1", <span class="code-comment">// agent(ag1)</span>
        "a2", <span class="code-comment">// agent(ag2)</span>
        "a3", <span class="code-comment">// agent(ag3)</span>
        "a4", <span class="code-comment">// agent(ag4)</span>
        "a5"  <span class="code-comment">// agent(ag5)</span>
    ],</span>
    ...
}
</pre>

<p>
<a href="http://www.w3.org/TR/2011/prov-dm/#record-ActivityAssociation">Activity Association Records</a>: the association of an agent with an activity is expressed with , and the nature of this association is described by attributes.  Illustrations of such attributes include the role of the participating agent, as creator, author and communicator (role is a reserved attribute in PROV-DM).</p>
<pre>
{
    ...
    <span class="code-new">"wasAssociatedWith": {
        <span class="code-comment">// wasAssociatedWith(a0, ag1, [prov:role="creator"])</span>
        "_:wAW1": {
            "activity" : "a0",
            "agent" : "ag1",
            "role": "creator"
        },
        <span class="code-comment">// wasAssociatedWith(a1, ag2, [prov:role="author"])</span>
        "_:wAW2": {
            "activity" : "a1",
            "agent" : "ag2",
            "role": "author"
        },
        <span class="code-comment">// wasAssociatedWith(a2, ag3, [prov:role="communicator"])</span>
        "_:wAW3": {
            "activity" : "a2",
            "agent" : "ag3",
            "role": "communicator"
        },
        <span class="code-comment">// wasAssociatedWith(a3, ag4, [prov:role="author"])</span>
        "_:wAW4": {
            "activity" : "a3",
            "agent" : "ag4",
            "role": "author"
        },
        <span class="code-comment">// wasAssociatedWith(a4, ag5, [prov:role="communicator"])</span>
        "_:wAW5": {
            "activity" : "a4",
            "agent" : "ag5",
            "role": "communicator"
        }
    },</span>
    ...
}
</pre>
</section> 
</section>


<section class="appendix"> 
<h2>Acknowledgements</h2> 
<p>This specification was developed based on the PROV-DM Specification [[PROV-DM]] and reused significant content therefrom to provide consistent mappings between the two documents.</p>
<p>Contributions to be listed here.</p> 
</section> 
   
 </body></html>
